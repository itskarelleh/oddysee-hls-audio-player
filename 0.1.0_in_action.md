this is notes based off the semi successful attempt at adding hls audio player core to Vibe Shift

DX Improvements for @hls-audio-player/core
1. Better Loading State Management
typescript
// Current: No way to know when it's ready
audioPlayer.setSource(url);
// We had to guess with polling/timeouts

// Better: Promise-based loading
await audioPlayer.setSource(url); // Promise that resolves when ready
// OR
audioPlayer.setSource(url).then(() => {}).catch(err => {});
2. Event System Instead of Polling
typescript
// Current: We had to poll getCurrentTrack() every 100ms
setInterval(() => {
  const track = audioPlayer.getCurrentTrack();
  // Check if track exists, has duration, etc.
}, 100);

// Better: Event-driven
audioPlayer.on('loadedmetadata', (track) => {
  console.log('Track ready:', track.duration);
});

audioPlayer.on('timeupdate', (currentTime) => {
  setCurrentTime(currentTime);
});

audioPlayer.on('ended', () => {
  goToNextTrack();
});

3. Type Safety & Interface Clarity
typescript
// Current: We had to create our own AudioTrack type
type AudioTrack = {
  currentTime?: number
  duration?: number
  [key: string]: any
}

// Better: Exported, well-defined interfaces
export interface AudioTrack {
  currentTime: number;
  duration: number;
  // ... other properties
}

export interface HLSAudioPlayer {
  setSource(url: string): Promise<void>;
  getCurrentTrack(): AudioTrack | null;
  on(event: string, callback: Function): void;
  off(event: string, callback: Function): void;
}

4. Better Error Handling
```typescript
// Current: Silent failures, hard to debug
audioPlayer.setSource(url); // No feedback if it fails

// Better: Clear error reporting
try {
  await audioPlayer.setSource(url);
} catch (error) {
  if (error.code === 'NETWORK_ERROR') {
    // Handle network issues
  } else if (error.code === 'FORMAT_NOT_SUPPORTED') {
    // Handle unsupported formats
  }
}
```

5. Loading States
```typescript
// Better: Expose loading states
audioPlayer.loading // boolean
audioPlayer.readyState // number (0-4 like HTML audio)
audioPlayer.error // Error | null
```

6. Simplified API
```typescript
// Current: Multiple steps needed
audioPlayer.setSource(url);
audioPlayer.setVolume(volume);
// Wait for it to be ready...
audioPlayer.play();

// Better: Chainable/fluent API
audioPlayer
  .setSource(url)
  .setVolume(volume)
  .play();

// OR config-based
const player = new HLSAudioPlayer({
  volume: 0.8,
  autoPlay: false,
  debug: true
});
```

7. Better Documentation
The biggest issue was not knowing:

- When tracks are actually ready
- What the Track interface looks like
- How to handle errors properly
- What events are available

8. React Integration
Consider a React-specific wrapper:

```typescript
// @hls-audio-player/react
const { player, isPlaying, currentTime, duration } = useHLSAudioPlayer({
  onTimeUpdate: (time) => setCurrentTime(time),
  onEnded: () => nextTrack(),
});
```

The core issue was that HLSAudioPlayer feels like a black box - we couldn't tell what was happening internally, which led to the timeout issues and polling approach. Better visibility into the player's state and lifecycle would make it much easier to work with!